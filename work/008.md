# Refactor 009: Code Organization

1. Establish a Standard Directory Structure

Adopting a conventional layout facilitates navigation and collaboration. Here's a recommended structure:​

```bash
/project-root
├── app/
│   └── Main.hs
├── src/
│   ├── TimeBandits/
│   │   ├── Syntax.hs
│   │   ├── Parser.hs
│   │   ├── Evaluator.hs
│   │   └── Internal/
│   │       └── Helpers.hs
│   └── ...
├── test/
│   ├── TimeBandits/
│   │   ├── SyntaxTest.hs
│   │   ├── ParserTest.hs
│   │   ├── EvaluatorTest.hs
│   │   └── ...
│   └── ...
├── dist/ (or .stack-work/)
├── LICENSE
├── README.md
├── Setup.hs
└── project.cabal
```

app/ Directory:

Contains the entry point(s) of the application. For multiple executables, each should have its own Main.hs within subdirectories.​
src/ Directory:

Holds all library source code, organized hierarchically to reflect module namespaces.​
test/ Directory:

Contains test suites, mirroring the structure of the src/ directory to ensure comprehensive coverage.​
dist/ or .stack-work/ Directory:

Generated by build tools (cabal or stack) to store build artifacts. Typically excluded from version control.​
Project Metadata Files:

LICENSE: Specifies the licensing terms.​

README.md: Provides an overview and usage instructions.​

Setup.hs: Custom build script, if necessary.​
Haskell Wiki

project.cabal: Defines the package, its dependencies, and build information.​

2. Align Modules with File Paths

Ensure each module's name corresponds to its file path. For example, the module TimeBandits.Syntax should reside in src/TimeBandits/Syntax.hs. This alignment is crucial for the compiler to locate modules correctly. ​

3. Implement Vertical Module Organization

Group related functionalities within cohesive modules, avoiding generic "Types" or "Utils" modules. This approach enhances modularity and reduces compilation dependencies. For example:​

TimeBandits.Syntax: Contains data types and functions related to the syntax of your domain.​

TimeBandits.Parser: Houses parsing logic specific to your application's needs.​

TimeBandits.Evaluator: Manages evaluation processes within your application.​

This method aligns with the guideline of organizing modules "vertically" by logical concept rather than by linguistic construct. ​
Haskell For All

4. Define Explicit Module Exports

Specify export lists in each module to control the visibility of functions and types, promoting encapsulation. For example:​

```haskell
module TimeBandits.Parser (parseExpression, parseFile) where
-- Function implementations
```

This practice ensures that only intended components are accessible to other modules, enhancing maintainability.​

1. Apply Consistent Naming Conventions

Adopt clear and consistent naming conventions for modules and functions to enhance readability and maintainability.​

Modules: Use UpperCamelCase (e.g., TimeBandits.Parser).​

Functions and Variables: Use camelCase (e.g., parseExpression).​

Types and Typeclasses: Start with an uppercase letter (e.g., Expression, Parser).​

These conventions align with standard Haskell practices. ​

6. Utilize Internal Modules for Non-Public Code

Place internal functionalities not intended for public use into modules prefixed with Internal. For example:​

```bash
/src/TimeBandits/Internal/
    └── Helpers.hs
```

This convention signals to developers that these modules are subject to change and should be used cautiously. ​

1. Integrate Code Formatting and Linting Tools

Use tools like hlint to enforce coding standards and identify potential improvements. Additionally, consider using brittany or ormolu for automatic code formatting. Integrating these tools into your development workflow ensures uniformity across the codebase.​

8. Maintain Comprehensive Documentation

Provide detailed documentation for each module and function using Haddock comments. For example:​

```haskell
-- | Parses an expression from a given string.
-- Returns either a 'ParseError' or an 'Expression'.
parseExpression :: String -> Either ParseError Expression
```

Well-documented code facilitates onboarding and aids in future development and maintenance efforts.​

9. Modularize Instances Appropriately

Define type class instances in the same module as the data type or the type class, depending on ownership. This strategy prevents orphan instances and maintains coherence in your codebase. ​

10. Organize Tests Correspondingly

Structure your test suite to reflect the organization of the source code. For each module in src/TimeBandits/, create a corresponding test module in test/TimeBandits/ to ensure comprehensive coverage and facilitate targeted testing.​