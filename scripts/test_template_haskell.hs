{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE TypeApplications #-}

module Main (main) where

import Polysemy (runM, interpret, Sem, Member, Embed, embed)
import Data.ByteString (ByteString)
import qualified Data.ByteString as BS
import qualified Data.ByteString.Char8 as BS8
import Data.Text (Text)
import qualified Data.Text as T
import Data.Time (UTCTime, getCurrentTime)

import TimeBandits.Core.Common.Types (LamportTime(..), Hash, PubKey(..), PrivKey(..), Signature(..))
import TimeBandits.Core.Types (AppError(..), ActorType(..), ResourceInfo(..), ActorHash)
import TimeBandits.Core.ResourceId (ResourceId)
import TimeBandits.Core.TimelineId (TimelineId)
import qualified TimeBandits.Core.Effect as Effect

-- Minimal implementation of test handlers
handleLogicalClock :: Member (Embed IO) r => Sem (Effect.LogicalClock ': r) a -> Sem r a
handleLogicalClock = interpret \case
  Effect.GetLamportTime -> embed $ pure (LamportTime 0)
  Effect.IncrementTime -> embed $ pure (LamportTime 1)
  Effect.UpdateTime t -> embed $ pure t

-- Main test function
main :: IO ()
main = do
  putStrLn "Testing Template Haskell Generated Functions"
  
  -- Test logical clock functions
  putStrLn "\nTesting Logical Clock Functions:"
  testLogicalClock
  
  putStrLn "\nAll tests completed!"

-- Test the logical clock functions
testLogicalClock :: IO ()
testLogicalClock = do
  -- We import the functions directly from Effect
  -- If they're not being generated by Template Haskell, this will fail at compile time
  putStrLn "  - Testing getLamportTime"
  time <- runM $ handleLogicalClock Effect.getLamportTime
  putStrLn $ "    Result: " ++ show time
  
  putStrLn "  - Testing incrementTime"
  newTime <- runM $ handleLogicalClock Effect.incrementTime
  putStrLn $ "    Result: " ++ show newTime 